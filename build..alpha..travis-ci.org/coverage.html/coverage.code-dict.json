{"/home/travis/build/npmtest/node-npmtest-node-red-contrib-firebase/test.js":"/* istanbul instrument in package npmtest_node_red_contrib_firebase */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-red-contrib-firebase/lib.npmtest_node_red_contrib_firebase.js":"/* istanbul instrument in package npmtest_node_red_contrib_firebase */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_red_contrib_firebase = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_red_contrib_firebase = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-red-contrib-firebase/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-red-contrib-firebase && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_red_contrib_firebase */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_red_contrib_firebase\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_red_contrib_firebase.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_node_red_contrib_firebase.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_red_contrib_firebase.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_node_red_contrib_firebase.__dirname + '/lib.npmtest_node_red_contrib_firebase.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-red-contrib-firebase/node_modules/node-red-contrib-firebase/firebase/firebase_auth.js":"module.exports = function(RED) {\n    'use strict';\n\n    function FirebaseAuth(n) {\n        RED.nodes.createNode(this,n);\n\n        this.config = RED.nodes.getNode(n.firebaseconfig);\n        this.name = n.name;\n        this.ready = false;\n\n        // Check credentials\n        if (!this.config) {\n            this.status({fill:\"red\", shape:\"ring\", text:\"invalid credentials\"})\n            this.error('You need to setup Firebase credentials!');\n            return\n        }\n\n        this.fbAuthorized = function(authData){\n          // this.log(\"authorized\")\n          this.status({fill:\"green\", shape:\"dot\", text:\"ready\"})\n          this.send({payload: authData})\n        }.bind(this)\n\n        this.fbUnauthorized = function(){\n          // this.log(\"unauthorized\")\n          this.status({fill:\"red\", shape:\"dot\", text:\"unauthorized\"})\n          this.send({payload: null})\n        }.bind(this)\n\n\n        //Register Handlers\n\n        this.config.fbConnection.on(\"authorized\", this.fbAuthorized)\n        this.config.fbConnection.on(\"unauthorized\", this.fbUnauthorized)\n\n        if(this.config.fbConnection.authData)\n            this.send({payload: this.config.fbConnection.authData})\n\n\n\n          this.on('close', function() {\n            //Cancel modify request to firebase??\n          });\n\n    }\n    RED.nodes.registerType(\"firebase auth\", FirebaseAuth);\n\n    RED.httpAdmin.post(\"/firebase/:id/auth\", RED.auth.needsPermission(\"firebase.write\"), function(req,res) {\n            var node = RED.nodes.getNode(req.params.id);\n            if (node !== null && typeof node !== \"undefined\" ) {\n                node.send({payload: node.config.fbConnection.authData});\n                res.sendStatus(200)\n            } else {\n                res.send(404);\n            }\n        });\n};\n","/home/travis/build/npmtest/node-npmtest-node-red-contrib-firebase/node_modules/node-red-contrib-firebase/firebase/firebase_config.js":"//All references to a Firebase share the same authentication status,\n//so if you call new Firebase() twice and call any authentication method\n//on one of them, they will both be authenticated.\nmodule.exports = function (RED) {\n    'use strict';\n    var Firebase = require('firebase');\n    var FirebaseTokenGenerator = require(\"firebase-token-generator\");\n    var events = require(\"events\");\n    var path = require(\"path\");\n    var https = require(\"follow-redirects\").https;\n    var urllib = require(\"url\");\n    // var async = require(\"async\")\n\n    function generateUID(){\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { //Generates a random RequestID\n          var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n          return v.toString(16);\n      });\n    }\n\n    // Firebase Full Authentication Error Listing - https://www.firebase.com/docs/web/guide/user-auth.html#section-full-error\n    // AUTHENTICATION_DISABLED\tThe requested authentication provider is disabled for this Firebase.\n    // EMAIL_TAKEN\tThe new user account cannot be created because the specified email address is already in use.\n    // INVALID_ARGUMENTS\tThe specified credentials are malformed or incomplete. Please refer to the error message, error details, and Firebase documentation for the required arguments for authenticating with this provider.\n    // INVALID_CONFIGURATION\tThe requested authentication provider is misconfigured, and the request cannot complete. Please confirm that the provider's client ID and secret are correct in your Firebase Dashboard and the app is properly set up on the provider's website.\n    // INVALID_CREDENTIALS\tThe specified authentication credentials are invalid. This may occur when credentials are malformed or expired.\n    // INVALID_EMAIL\tThe specified email is not a valid email.\n    // INVALID_ORIGIN\tA security error occurred while processing the authentication request. The web origin for the request is not in your list of approved request origins. To approve this origin, visit the Login & Auth tab in your Firebase dashboard.\n    // INVALID_PASSWORD\tThe specified user account password is incorrect.\n    // INVALID_PROVIDER\tThe requested authentication provider does not exist. Please consult the Firebase authentication documentation for a list of supported providers.\n    // INVALID_TOKEN\tThe specified authentication token is invalid. This can occur when the token is malformed, expired, or the Firebase secret that was used to generate it has been revoked.\n    // INVALID_USER\tThe specified user account does not exist.\n    // NETWORK_ERROR\tAn error occurred while attempting to contact the authentication server.\n    // PROVIDER_ERROR\tA third-party provider error occurred. Please refer to the error message and error details for more information.\n    // TRANSPORT_UNAVAILABLE\tThe requested login method is not available in the user's browser environment. Popups are not available in Chrome for iOS, iOS Preview Panes, or local, file:// URLs. Redirects are not available in PhoneGap / Cordova, or local, file:// URLs.\n    // UNKNOWN_ERROR\tAn unknown error occurred. Please refer to the error message and error details for more information.\n    // USER_CANCELLED\tThe current authentication request was cancelled by the user.\n    // USER_DENIED\tThe user did not authorize the application. This error can occur when the user has cancelled an OAuth authentication request.\n\n    //TODO: Where is the full Firebase Error listing for .set(), etc.?\n\n    //connectionPool is responsible for managing Firebase Connections, Authentication, etc.\n    //connectionPool emits the following events:\n      //initializing\n      //connected\n      //disconnected\n      //authorized\n      //unauthorized\n      //error //TODO: need to wrap everything in a try/catch to make sure we don't ever crash node-red\n      //closed\n    var connectionPool = function(){  //TODO: This could probably be refactored to be a bit simpler now...\n      var connections = {}\n\n      return {\n        get: function(firebaseurl, configNodeID){\n          if(!connections[configNodeID]){ //Lazily create a new Firebase Reference if it does not exist\n\n            connections[configNodeID] = function(){\n\n              //Private\n              var _emitter = new events.EventEmitter();\n              var _emit = function(a,b){\n                //console.log(firebaseurl + \" - emitting \" + a)\n                if(this.lastEvent == a && this.lastEventData == b){\n                  //console.log(\"ignoring duplicate emit event \" + a)\n                  return\n                }\n\n                this.lastEvent = a;\n                this.lastEventData = b;\n\n                _emitter.emit(a,b)\n              }\n\n\n              var obj = {\n                Firebase: Firebase,  //Needed for Firebase.ServerValue.TIMESTAMP...\n\n                firebaseurl: firebaseurl,  //TODO: Some of this data is duplicated...\n                fbRef: new Firebase(firebaseurl, configNodeID), //Including a second argument is a hack which allows us to have multiple auths connected to the same Firebase - see https://github.com/deldrid1/node-red-contrib-firebase/issues/3\n                authData: null, //TODO: Some of this data is duplicated...\n                loginType: null,\n                secret: null,\n                passORuid: null,  //TODO: Probably should clean this up similair to the config node to make it less confusing what is going on...\n                nodeCount: 0,\n                lastEvent: \"initializing\",\n                lastEventData: null,\n                httpRequests: {},\n\n                on: function(a,b) { _emitter.on(a,b); },\n                once: function(a,b) { _emitter.once(a,b); },\n\n                authorize: function(loginType, secret, passORuid, jwtClaims){\n                  //console.log(\"Attempting to authorize with loginType=\"+loginType+\" with secret=\"+secret+\" and pass/uid=\"+passORuid)\n\n                  if(this.loginType && this.authData){\n                    this.authData = null\n                    this.fbRef.offAuth(this.onAuth, this);\n                    this.fbRef.unauth();\n                    _emit(\"unauthorized\");\n                  }\n\n                  this.loginType = loginType\n                  this.secret = secret\n                  this.passORuid = passORuid\n\n                  switch (loginType) {\n                      case 'none':\n                          process.nextTick(function(){\n                            _emit(\"authorized\", null)\n                          }.bind(this));\n                          break;\n                      case 'jwt':\n                          this.fbRef.authWithCustomToken(secret, this.onLoginAuth.bind(this))\n                          this.fbRef.onAuth(this.onAuth, this);\n                          break;\n                      case 'anonymous':\n                          this.fbRef.authAnonymously(this.onLoginAuth.bind(this));\n                          this.fbRef.onAuth(this.onAuth, this);\n                          break;\n                      case 'customGenerated':\n                            var tokenGenerator = new FirebaseTokenGenerator(secret);\n                            // expires (Number) - A timestamp (as number of seconds since the epoch) denoting the time after which this token should no longer be valid.\n                            // notBefore (Number) - A timestamp (as number of seconds since the epoch) denoting the time before which this token should be rejected by the server.\n                            // admin (Boolean) - Set to true if you want to disable all security rules for this client. This will provide the client with read and write access to your entire Firebase.\n                            // debug (Boolean) - Set to true to enable debug output from your security rules. This debug output will be automatically output to the JavaScript console. You should generally not leave this set to true in production (as it slows down the rules implementation and gives your users visibility into your rules), but it can be helpful for debugging.\n                            var tokenArgs = {uid: passORuid, generator: \"node-red\"}\n                            for(var i = 0; i < jwtClaims.length; i++)\n                              tokenArgs[jwtClaims[i].key] = jwtClaims[i].value\n\n                            var token = tokenGenerator.createToken(tokenArgs);\n\n                            this.fbRef.authWithCustomToken(token, this.onLoginAuth.bind(this))\n                            this.fbRef.onAuth(this.onAuth, this);\n                            break;\n\n                      case 'email':\n                          this.fbRef.authWithPassword({\n                              email: secret,\n                              password: passORuid\n                            }, this.onLoginAuth.bind(this))\n\n                          this.fbRef.onAuth(this.onAuth, this);\n                          break;\n                      // default:\n                      //   console.log(\"ERROR: Invalid loginType in firebase \" + this.firebaseurl + \" config - \" + this.loginType)\n                      //   this.status({fill:\"red\", shape:\"ring\", text:\"invalid loginType\"})\n                      //   break;\n                  }\n                },\n\n\n                //Note, connected and disconnected can happen without our auth status changing...\n                onConnectionStatusChange: function(snap){\n                  //var obj = connections[snap.ref().parent().parent().toString()]  //Not the most elegant, but it works\n                  if (snap.val() === true) {\n                    if(this.lastEvent != \"authorized\")//TODO: BUG: there is some kind of sequencing bug that can cause connected to be set to true after we have already emitted that authorized is true.  This is patch for that issue but we really should ge tht execution order correct...\n                      _emit(\"connected\")\n                  } else {\n                    _emit(\"disconnected\")\n                  }\n                },\n\n                //However, it looks like with our current setup auth will get re-emitted after we reconnect.\n                onAuth: function(authData){\n                  if(authData){\n                    _emit(\"authorized\", authData)\n                  } else {\n                    if(this.authData){\n                      var now = new Date()\n                      var authExpiration = new Date(this.authData.expires*1000)\n\n                      if(authExpiration.getTime()-10000 <= now.getTime()){  //TODO: Do some research on this, we are subtracting 10 seconds - Firebase gets a little greedy with expirations (perhaps this is because of clock differences and network latencies?)\n                        //Auth has expired - need to reauthorize\n                        console.log(\"auth has expired - attempting single shot reauthentication\")\n                        this.authorize(this.loginType, this.secret, this.passORuid) //Single Shot Reauth attempt\n                      }\n                    }\n                    _emit(\"unauthorized\");\n                  }\n\n                  this.authData = authData\n                },\n\n                onLoginAuth: function(error, authData) {\n                  if (error) {\n                    // switch (error.code) {\n                    //   case \"INVALID_EMAIL\":\n                    //     error = \"The specified user account email is invalid.\";\n                    //     break;\n                    //   case \"INVALID_PASSWORD\":\n                    //     error = \"The specified user account password is incorrect.\";\n                    //     break;\n                    //   case \"INVALID_USER\":\n                    //     error = \"The specified user account does not exist.\";\n                    //     break;\n                    //   default:\n                    //     error = \"Error logging user in: \" + error.toString();\n                    // }\n                    _emit(\"error\", error.code);  //TODO: evaluate being verbose vs. using the error.code...\n                  } //else //onAuth handles success conditions\n                      //console.log(\"onLoginAuth Success: Logged into  \" + this.firebaseurl + \" as \" + JSON.stringify(authData))\n                },\n\n                close: function(){\n                  _emit(\"closed\")\n                  _emitter.removeAllListeners();  //Makes sure everybody stopped listening to us... //TODO: This may prevent nodes from receiving the \"closed\" event...\n\n                  //Clean up the Firebase Reference and tear down the connection\n\n                  this.fbRef.child(\".info/connected\").off(\"value\", obj.onConnectionStatusChange, obj);\n\n                  if(this.loginType){\n                    this.fbRef.offAuth(obj.onAuth, obj);\n                    this.fbRef.unauth();\n                  }\n                }\n              }\n\n\n\n              //Set \"this\" in our private functions\n              _emit = _emit.bind(obj);\n              _emitter.setMaxListeners(0);  //Suppress Memory Leak warnings, 0 means unlimited listeners\n              process.nextTick(function(){\n                _emitter.emit(\"initializing\");  //_emit would suppress this because of the default value...\n                obj.fbRef.child(\".info/connected\").on(\"value\", obj.onConnectionStatusChange, obj);\n              }.bind(obj))\n\n              return obj;\n            }();\n          }\n\n          connections[configNodeID].nodeCount++;\n\n          return connections[configNodeID]\n        },\n\n        close: function(configNodeID){\n          var obj = connections[configNodeID]\n\n          obj.nodeCount--\n\n          if(obj.nodeCount == 0){\n            obj.close()\n\n            delete connections[configNodeID]\n            //TODO: BUG: there is not way to do close/kill a connection with the current Firebase Library.  It is a low priority for them but is scheduled for release middle of 2015...    http://stackoverflow.com/questions/27641764/how-to-destroy-firebase-ref-in-node\n          }\n        }\n      }\n    }();\n\n    function FirebaseConfig(n) {\n        RED.nodes.createNode(this, n);\n\n        // this.log(JSON.stringify(n, null, \"\\t\"))\n        // this.log(JSON.stringify(this, null, \"\\t\"))\n\n        //TODO: Input validation on the server (we are doing it on the client but not doing anything here...)\n        this.firebaseurl = \"https://\" + n.firebaseurl + \".firebaseio.com\";\n        this.loginType = n.loginType;\n        this.uid = this.credentials.uid;\n        this.secret = this.credentials.secret;\n        this.email = this.credentials.email;\n        this.password = this.credentials.password;\n        this.jwtClaims = JSON.parse(this.credentials.jwtClaims != undefined ? this.credentials.jwtClaims : \"[]\");\n\n        this.fbConnection = connectionPool.get(this.firebaseurl, this.id)\n\n        this.fbConnection.on(\"initializing\", function(){\n          // this.log(\"initializing to \" + this.firebaseurl)\n          this.status({fill:\"grey\", shape:\"ring\", text:\"initializing...\"})\n        }.bind(this))\n\n        this.fbConnection.on(\"connected\", function(){\n          // this.log(\"connected to \" + this.firebaseurl)\n          switch (this.loginType) {\n              case 'none':\n              case 'anonymous':\n                this.fbConnection.authorize(this.loginType);\n                break;\n              case 'jwt':  //TODO:\n                this.fbConnection.authorize(this.loginType, this.secret);\n                break;\n              case 'email':\n                this.fbConnection.authorize(this.loginType, this.email, this.password);\n                break;\n              case 'customGenerated':\n              this.fbConnection.authorize(this.loginType, this.secret, this.uid, this.jwtClaims);\n                break;\n              case 'facebook': //TODO:\n                break;\n              case 'twitter': //TODO:\n                break;\n              case 'github': //TODO:\n                break;\n              case 'google': //TODO:\n                break;\n              default:\n                this.error(\"Invalid loginType in firebase \" + this.firebaseurl + \" config - \" + this.loginType, {})\n                this.status({fill:\"red\", shape:\"ring\", text:\"invalid loginType\"})\n                break;\n          }\n          this.status({fill:\"green\", shape:\"ring\", text:\"connected\"})\n        }.bind(this))\n\n        this.fbConnection.on(\"disconnected\", function(){\n          // this.log(\"disconnected from \" + this.firebaseurl)\n          this.status({fill:\"red\", shape:\"ring\", text:\"disconnected\"})\n        }.bind(this))\n\n        this.fbConnection.on(\"authorized\", function(authData){\n          // this.log(\"authorized to \" + this.firebaseurl + (authData ? \" as \" + JSON.stringify(authData) : \" without auth\"))\n        }.bind(this))\n\n        this.fbConnection.on(\"unauthorized\", function(){\n          // this.log(\"unauthorized from \" + this.firebaseurl)\n          this.status({fill:\"red\", shape:\"dot\", text:\"unauthorized\"})\n        }.bind(this))\n\n        this.fbConnection.on(\"error\", function(error){\n          // this.log(\"error [\" + this.firebaseurl + \"] - \" + error)\n          this.status({fill:\"red\", shape:\"ring\", text:error})\n          this.error(JSON.stringify(error), error);//TODO: BUG: Config nodes have no where to pass there second error param...\n        }.bind(this))\n\n        // this.on('input', function(msg) { //Meaningless in a Config Node\n        //     // do something with 'msg'\n        // });\n\n        //this.send({payload: \"hi\"})  //Also meaningless for Config Nodes\n\n        this.on('close', function() {\n            this.status({fill: \"gray\", shape: \"dot\", text:\"connection closed\"})\n            // We need to unbind our callback, or we'll get duplicate messages when we redeploy\n            connectionPool.close(this.id)\n        });\n    }\n\n    RED.nodes.registerType('firebase config', FirebaseConfig, {\n      credentials: {\n          loginType: {type: 'text'},\n          uid: {type: 'text'},\n          secret: {type: 'password'},\n          email: {type: 'text'},\n          password: {type: 'password'},\n          jwtClaims: {type: 'text'}\n      }\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-node-red-contrib-firebase/node_modules/node-red-contrib-firebase/firebase/firebase_modify.js":"module.exports = function(RED) {\n  'use strict';\n\n  String.prototype.capitalize = function() {\n      return this.charAt(0).toUpperCase() + this.slice(1);\n  }\n\n  function FirebaseModify(n) {\n      RED.nodes.createNode(this,n);\n\n      this.config = RED.nodes.getNode(n.firebaseconfig);\n      this.childpath = n.childpath;\n      this.value = n.value;\n      this.method = n.method;\n      this.priority = n.priority;\n      this.fbRequests = [];\n\n      this.ready = false;\n\n      this.validMethods = {\n        \"set\": true,\n        \"update\": true,\n        \"push\": true,\n        \"remove\": true,\n    \t\t\"setPriority\": true,\n    \t\t\"setWithPriority\": true\n      }\n\n      // Check credentials\n      if (!this.config) {\n          this.status({fill:\"red\", shape:\"ring\", text:\"invalid credentials\"})\n          this.error('You need to setup Firebase credentials!');\n          return\n      }\n\n      this.fbOnComplete = function(error) {\n          //this.log(\"fb oncomplete.  error = \" + error)\n          var msg = this.fbRequests.shift() //Firebase will call these in order for us\n          //TODO: Once Node-Red supports it, we should flash the Node when we receive this data.\n          if(error){\n            this.log(\"firebase synchronization failed\")\n            this.error(\"firebase synchronization failed - \" + error, msg)\n          } else {\n          \tthis.send(msg)\n          }\n      }.bind(this);\n\n\n      //this.config.fbConnection EventEmitter Handlers\n      this.fbInitializing = function(){  //This isn't being called because its emitted too early...\n        this.status({fill:\"grey\", shape:\"ring\", text:\"initializing...\"})\n        this.ready = false;\n      }.bind(this)\n\n      this.fbConnected = function(){\n        this.status({fill:\"green\", shape:\"ring\", text:\"connected\"})\n        this.ready = false;\n      }.bind(this)\n\n      this.fbDisconnected = function(){\n        this.status({fill:\"red\", shape:\"ring\", text:\"disconnected\"})\n        this.ready = false;\n      }.bind(this)\n\n      this.fbAuthorized = function(authData){\n        this.status({fill:\"green\", shape:\"dot\", text:\"ready\"})\n        this.ready = true;\n      }.bind(this)\n\n      this.fbUnauthorized = function(){\n        this.status({fill:\"red\", shape:\"dot\", text:\"unauthorized\"})\n        this.ready = false;\n      }.bind(this)\n\n      this.fbError = function(error){\n        this.status({fill:\"red\", shape:\"ring\", text:error})\n      }.bind(this)\n\n      this.fbClosed = function(error){\n        this.status({fill: \"gray\", shape: \"dot\", text:\"connection closed\"})\n        this.ready = false;\n      }.bind(this)\n\n\n      //Register Handlers\n      this.config.fbConnection.on(\"initializing\", this.fbInitializing)\n      this.config.fbConnection.on(\"connected\", this.fbConnected)\n      this.config.fbConnection.on(\"disconnected\", this.fbDisconnected)\n      this.config.fbConnection.on(\"authorized\", this.fbAuthorized)\n      this.config.fbConnection.on(\"unauthorized\", this.fbUnauthorized)\n      this.config.fbConnection.on(\"error\", this.fbError)\n      this.config.fbConnection.on(\"closed\", this.fbClosed)\n\n      //set initial state (depending on the deployment strategy, for newly deployed nodes, some of the events may not be refired...)\n      switch(this.config.fbConnection.lastEvent) {\n        case \"initializing\":\n        case \"connected\":\n        case \"disconnected\":\n        case \"authorized\":\n        case \"unauthorized\":\n        case \"error\":\n        case \"closed\":\n          this[\"fb\" + this.config.fbConnection.lastEvent.capitalize()](this.config.fbConnection.lastEventData)  //Javascript is really friendly about sending arguments to functions...\n          break;\n        // case \"undefined\":\n        // case \"null\":\n        //   break;  //Config node not yet setup\n        default:\n          this.error(\"Bad lastEvent Data from Config Node - \" + this.config.fbConnection.lastEvent)\n      }\n\n\n      this.on('input', function(msg) {\n        if(this.ready){\n\n          //TODO: this seems to be mostly working, but we really ought to do some more due diligence here...\n          //Try to convert to JSON object...\n          //Parse out msg.method\n          var method = this.method\n          if(method == \"msg.method\"){\n            if(\"method\" in msg){\n              method = msg.method\n            } else {\n              this.error(\"Expected \\\"method\\\" property in msg object\", msg)\n              return;\n            }\n          }\n\n          //Parse out msg.payload\n          var value = this.value;\n          if (method != \"setPriority\"){\n            if (value == \"msg.payload\"){\n              if (\"payload\" in msg){\n                value = msg.payload;\n                if (!Buffer.isBuffer(value) && typeof value != \"object\"){\n                  try {\n                    value = JSON.parse(value)\n                  } catch(e){\n                    value = msg.payload.toString();\n                  }\n                }\n              } else {\n                this.warn(\"Expected \\\"payload\\\" property not in msg object (setting payload to \\\"null\\\")\", msg);\n                value = null;\n              }\n            } else if(this.value == \"Firebase.ServerValue.TIMESTAMP\") {\n              value = this.config.fbConnection.Firebase.ServerValue.TIMESTAMP\n            }\n            msg.payload = value;\n          }\n\n          //Parse out msg.priority\n          var priority = null;\n          if (method == \"setPriority\" || method == \"setWithPriority\"){\n            priority = this.priority;\n            if (priority == null){\n              this.error(\"Expected \\\"priority\\\" property not included\", msg)\n              return;\n            } else if (priority == \"msg.priority\"){\n              if (\"priority\" in msg) priority = msg.priority;\n              else {\n                this.error(\"Expected \\\"priority\\\" property in msg object\", msg)\n                return;\n              }\n            }\n          }\n\n          //Parse out msg.childpath\n          var childpath = this.childpath\n          if(childpath == \"msg.childpath\"){\n            if(\"childpath\" in msg){\n              childpath = msg.childpath\n            }\n          }\n          childpath = childpath || \"/\"\n\n          switch (method){\n            case \"set\":\n            case \"update\":\n              this.fbRequests.push(msg)\n              this.config.fbConnection.fbRef.child(childpath)[method](msg.payload, this.fbOnComplete.bind(this)); //TODO: Why doesn't the Firebase API support passing a context to these calls?\n              break;\n            case \"push\":\n              var pushRef = this.config.fbConnection.fbRef.child(childpath)[method]();\n              msg.pushID = pushRef.key();\n              this.fbRequests.push(msg)\n              pushRef.set(msg.payload, this.fbOnComplete.bind(this)); //TODO: Why doesn't the Firebase API support passing a context to these calls?\n              break;\n            case \"remove\":\n              this.fbRequests.push(msg)\n              this.config.fbConnection.fbRef.child(childpath)[method](this.fbOnComplete.bind(this));\n              break;\n            case \"setPriority\":\n              this.fbRequests.push(msg)\n              this.config.fbConnection.fbRef.child(childpath)[method](priority, this.fbOnComplete.bind(this));\n              break;\n            case \"setWithPriority\":\n              this.fbRequests.push(msg)\n              this.config.fbConnection.fbRef.child(childpath)[method](msg.payload, priority, this.fbOnComplete.bind(this));\n              break;\n            default:\n              this.error(\"Invalid msg.method property \\\"\" + method + \"\\\".  Expected one of the following: [\\\"\" + Object.keys(this.validMethods).join(\"\\\", \\\"\") + \"\\\"].\", msg)\n              break;\n          }\n        } else {\n          this.warn(\"Received msg before firebase modify node was ready.  Not processing: \" + JSON.stringify(msg, null, \"\\t\"))\n        }\n      });\n\n\n      this.on('close', function() {\n        //Cancel modify request to firebase??\n      });\n\n  }\n  RED.nodes.registerType(\"firebase modify\", FirebaseModify);\n};\n","/home/travis/build/npmtest/node-npmtest-node-red-contrib-firebase/node_modules/node-red-contrib-firebase/firebase/firebase_off.js":"module.exports = function(RED) {\n    'use strict';\n\n    function FirebaseOff(n) {\n        RED.nodes.createNode(this,n);\n\n        this.config = RED.nodes.getNode(n.firebaseconfig);\n        this.childpath = n.childpath;\n        this.eventType = n.eventType;\n\n        // Check credentials\n        if (!this.config) {\n            this.status({fill:\"red\", shape:\"ring\", text:\"invalid credentials\"})\n            this.error('You need to setup Firebase credentials!');\n            return\n        }\n\n        this.validEventTypes = {\n          \"value\": true,\n          \"child_added\": true,\n          \"child_changed\": true,\n          \"chiled_removed\": true,\n          \"child_moved\": true,\n          \"shallow_query\": true\n        }\n\n        this.setStatus = function(error){\n          //set = state (depending on the deployment strategy, for newly deployed nodes, some of the events may not be refired...)\n          switch(this.config.fbConnection.lastEvent) {\n            case \"initializing\":\n              this.status({fill:\"grey\", shape:\"ring\", text:\"initializing...\"})\n              break;\n            case \"connected\":\n              this.status({fill:\"green\", shape:\"ring\", text:\"connected\"})\n              break;\n            case \"disconnected\":\n              this.status({fill:\"red\", shape:\"ring\", text:\"disconnected\"})\n              break;\n            case \"authorized\":\n              this.status({fill:\"green\", shape:\"dot\", text:\"ready\"})\n              break;\n            case \"unauthorized\":\n              this.status({fill:\"red\", shape:\"dot\", text:\"unauthorized\"})\n              break;\n            case \"error\":\n              this.status({fill:\"red\", shape:\"ring\", text:error || \"error\"}) //TODO: should we store the last error?\n              break;\n            case \"closed\":\n              this.status({fill: \"gray\", shape: \"dot\", text:\"connection closed\"})\n              break;\n            // case \"undefined\":\n            // case \"null\":\n            //   break;  //Config node not yet setup\n            default:\n              this.error(\"Bad lastEvent Data from Config Node - \" + this.config.fbConnection.lastEvent)\n          }\n\n        }.bind(this)\n\n        //this.config.fbConnection EventEmitter Handlers\n        this.fbInitializing = function(){  //This isn't being called because its emitted too early...\n          // this.log(\"initializing\")\n          this.setStatus();\n        }.bind(this)\n\n        this.fbConnected = function(){\n          // this.log(\"connected\")\n          this.setStatus();\n        }.bind(this)\n\n        this.fbDisconnected = function(){\n          // this.log(\"disconnected\")\n          this.setStatus();\n        }.bind(this)\n\n        this.fbAuthorized = function(authData){\n          // this.log(\"authorized\")\n          this.setStatus();\n        }.bind(this)\n\n        this.fbUnauthorized = function(){\n          // this.log(\"unauthorized\")\n          this.setStatus();\n        }.bind(this)\n\n        this.fbError = function(error){\n          // this.log(\"error - \" + error)\n          this.setStatus(error);\n          this.error(error, {})\n        }.bind(this)\n\n        this.fbClosed = function(){\n          // this.log(\"closed\")\n          this.setStatus();\n        }.bind(this)\n\n\n        //Register Handlers\n        this.config.fbConnection.on(\"initializing\", this.fbInitializing)\n        this.config.fbConnection.on(\"connected\", this.fbConnected)\n        this.config.fbConnection.on(\"disconnected\", this.fbDisconnected)\n        this.config.fbConnection.on(\"authorized\", this.fbAuthorized)\n        this.config.fbConnection.on(\"unauthorized\", this.fbUnauthorized)\n        this.config.fbConnection.on(\"error\", this.fbError)\n        this.config.fbConnection.on(\"closed\", this.fbClosed)\n\n        // this.log(\"setting initial state to [fb\" + this.config.fbConnection.lastEvent.capitalize()+ \"](\"+this.config.fbConnection.lastEventData+\")\" )\n\n        //set initial state (depending on the deployment strategy, for newly deployed nodes, some of the events may not be refired...)\n        this[\"fb\" + this.config.fbConnection.lastEvent.capitalize()](this.config.fbConnection.lastEventData)  //Javascript is really friendly about sending arguments to functions...\n\n        this.on('input', function(msg) {\n              var eventType = this.eventType\n              if(eventType == \"msg.eventType\"){\n                if(\"eventType\" in msg){\n                  eventType = msg.eventType\n                } else {\n                  this.error(\"Expected \\\"eventType\\\" property in msg object\", msg)\n                  return;\n                }\n              }\n\n              if(!(eventType in this.validEventTypes)){\n                this.error(\"Invalid msg.eventType property \\\"\" + eventType + \"\\\".  Expected one of the following: [\\\"\" + Object.keys(this.validEventTypes).join(\"\\\", \\\"\") + \"\\\"].\", msg)\n                return;\n              }\n\n              //Parse out msg.childpath\n              var childpath = this.childpath\n              if(childpath == \"msg.childpath\"){\n                if(\"childpath\" in msg){\n                  childpath = msg.childpath\n                }\n              }\n              childpath = childpath || \"/\"\n\n              msg.eventType = eventType;\n              msg.childpath = childpath || \"/\";\n\n              if(msg.childpath)\n                this.config.fbConnection.fbRef.child(msg.childpath).off(msg.eventType) //, this.onFBValue, this); //TODO: BUG: this is a little more overzealous than it should be but I don't have a good way for the node to send its own ID down the flow currently...\n              else\n                this.config.fbConnection.fbRef.off(msg.eventType) //, this.onFBValue, this);  //TODO: BUG: this is a little more overzealous than it should be but I don't have a good way for the node to send its own ID down the flow currently...\n        });\n\n        this.on('close', function() {\n          this.destroyListeners();\n        });\n\n    }\n    RED.nodes.registerType('firebase.off', FirebaseOff);\n};\n","/home/travis/build/npmtest/node-npmtest-node-red-contrib-firebase/node_modules/node-red-contrib-firebase/firebase/firebase_once.js":"module.exports = function(RED) {\n    'use strict';\n    var https = require(\"follow-redirects\").https;\n    var urllib = require(\"url\");\n\n    var getPushIdTimestamp = (function getPushIdTimestamp() {\n      var PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\n\n      return function getTimestampFromId(id) {\n        try {\n          var time = 0;\n          var data = id.substr(0, 8);\n\n          for (var i = 0; i < 8; i++) {\n            time = time * 64 + PUSH_CHARS.indexOf(data[i]);\n          }\n\n          return time;\n        } catch(ex){}\n      }\n    })();\n\n    function FirebaseOnce(n) {\n        RED.nodes.createNode(this,n);\n\n        this.config = RED.nodes.getNode(n.firebaseconfig);\n        this.childpath = n.childpath;\n        this.eventType = n.eventType;\n        this.queries = n.queries;\n        this.repeatifnull = n.repeatifnull;\n\n        this.activeRequests = [];\n        this.ready = false;\n\n        // Check credentials\n        if (!this.config) {\n            this.status({fill:\"red\", shape:\"ring\", text:\"invalid credentials\"})\n            this.error('You need to setup Firebase credentials!');\n            return\n        }\n\n        // for (var i=0; i<this.queries.length; i+=1) {\n        //     var query = this.queries[i];\n        //     if (!isNaN(Number(query.value))) {\n        //       query.value = Number(query.value);\n        //       query.value2 = Number(query.value2);\n        //     }\n        // }\n\n        this.validEventTypes = {\n          \"value\": true,\n          \"child_added\": true,\n          \"child_changed\": true,\n          \"chiled_removed\": true,\n          \"child_moved\": true,\n          \"shallow_query\": true\n        }\n\n        this.onFBData = function(snapshot, prevChildName) {\n            //console.log(\"In onFBData + \" + JSON.stringify(snapshot.val()))\n            //TODO: Once Node-Red supports it, we should flash the Node when we receive this data.\n\n            // if(!snapshot.exists()){\n            //   //The code below will simply send a payload of nul if there is no data\n            // }\n\n            //Tstart with original message object so we retain all of those properties...\n            var msg = this.activeRequests.shift();\n\n            msg.href = snapshot.ref().toString();\n            msg.key = snapshot.key();\n            msg.payload = snapshot.val();\n            if(snapshot.getPriority())\n              msg.priority = snapshot.getPriority();\n            if(prevChildName)\n              msg.previousChildName = prevChildName;\n            if(this.eventType.search(\"child\") != -1 || msg.key.length == 20 && getPushIdTimestamp(msg.key))  //We probably have a pushID that we can decode\n              msg.pushIDTimestamp = getPushIdTimestamp(msg.key)\n\n            if(this.repeatifnull && msg.payload == null && msg.attemptNumber++ < 100 ){ // Repeat sending the request.  //TODO: we could use a configurable timer in seconds or a configurable number of attempts\n              this.registerListeners(msg)\n            } else {\n              this.send(msg);\n            }\n\n            this.setStatus();\n        }.bind(this);\n\n        this.onFBError = function(error){\n          this.error(error, {})\n          this.status({fill:\"red\",shape:\"ring\",text:error.code || \"error\"});\n          setTimeout(this.setStatus, 5000)  //Reset back to the Firebase status after 5 seconds\n        }.bind(this);\n\n        this.registerListeners = function(msg){\n\n          var eventType = this.eventType\n          if(eventType == \"msg.eventType\"){\n            if(\"eventType\" in msg){\n              eventType = msg.eventType\n            } else {\n              this.error(\"Expected \\\"eventType\\\" property in msg object\", msg)\n              return;\n            }\n          }\n\n          if(!(eventType in this.validEventTypes)){\n            this.error(\"Invalid msg.eventType property \\\"\" + eventType + \"\\\".  Expected one of the following: [\\\"\" + Object.keys(this.validEventTypes).join(\"\\\", \\\"\") + \"\\\"].\", msg)\n            return;\n          }\n\n          //Parse out msg.childpath\n          var childpath = this.childpath\n          if(childpath == \"msg.childpath\"){\n            if(\"childpath\" in msg){\n              childpath = msg.childpath\n            }\n          }\n          childpath = childpath || \"/\"\n\n          msg.eventType = eventType;\n          msg.childpath = childpath || \"/\";\n\n          if(!msg.attemptNumber)\n            msg.attemptNumber = 0\n\n          this.activeRequests.push(msg)\n\n          if(msg.eventType == \"shallow_query\"){\n            this.shallowQuery(msg)  //TODO: https://www.firebase.com/docs/rest/guide/retrieving-data.html#section-rest-ordered-data and https://www.firebase.com/docs/rest/guide/retrieving-data.html#section-rest-queries\n          } else {\n            this.fbOnce(eventType, msg);\n          }\n\n        }.bind(this);\n\n        this.destroyListeners = function(reason){\n          if(this.activeRequests.length > 0 && reason){  //ensure the close function doesn't trigger this\n            // var msg = {};\n            // msg.href = this.config.firebaseurl;\n            // msg.payload = \"ERROR: \" + reason;\n            var msg = this.activeRequests.shift()\n            this.error(reason, msg)\n\n            var eventType = this.eventType\n            if(eventType == \"msg.eventType\")\n              eventType = msg.eventType\n\n            if(!(eventType in this.validEventTypes)){\n              //this.error(\"Invalid eventType - \\\"\" + eventType + \"\\\"\", msg)  //We have already errored on the registerListener call\n              return;\n            }\n\n            // We need to unbind our callback, or we'll get duplicate messages when we redeploy\n            if(msg.childpath)\n              this.config.fbConnection.fbRef.child(msg.childpath).off(eventType, this.onFBData, this);\n            else\n              this.config.fbConnection.fbRef.off(eventType, this.onFBData, this);\n          }\n        }.bind(this);\n\n        this.fbOnce = function(eventType, msg){\n          this.status({fill:\"blue\",shape:\"dot\",text:\"requesting from firebase...\"});\n\n          //Create the firebase reference to the path\n          var ref\n          if(msg.childpath){\n            ref = this.config.fbConnection.fbRef.child(msg.childpath)\n          }else{\n            ref = this.config.fbConnection.fbRef\n          }\n\n\n          //apply the queries\n          for (var i=0; i<this.queries.length; i+=1) {\n              var query = this.queries[i];\n              var val\n\n              switch(query.name){\n                case \"orderByKey\":\n                case \"orderByValue\":\n                case \"orderByPriority\":\n                  ref = ref[query.name]()  //No args //TODO: BUG: Update HTML to hide box for these 3...\n                  break;\n\n                case \"orderByChild\":\n                case \"startAt\":\n                case \"endAt\":\n                case \"equalTo\":\n                case \"limitToFirst\":\n                case \"limitToLast\":\n                  //try to convert to native type for bools, ints, etc.\n                  try{ val = JSON.parse(query.value.toLowerCase() || query.value) }\n                  catch(e){ val = query.value}\n\n                  ref = ref[query.name](val) //TODO: no error checking...\n                  break;\n\n                default:\n                  //TODO:\n                  break;\n              }\n\n\n          }\n\n          ref.once(eventType, this.onFBData, this.onFBError, this);\n        }.bind(this)\n\n        this.shallowQuery = function(msg){  //Could we use the REST Streaming API and do shallow queries in firebase.on()? Update - currently firebase doesn't support shallow and query args in the same request\n          this.status({fill:\"blue\",shape:\"dot\",text:\"shallow_query requesting...\"});\n\n          // make sure the path starts with '/'\n          var childpath = (msg.childpath.indexOf(\"/\") == 0) ? msg.childpath : \"/\" + msg.childpath;\n          //make sure the path does not end with '/', (unless that is the string in its entirety)\n          childpath = (childpath.length != 1 && childpath.substr(-1) == \"/\") ? childpath.slice(0,-1) : childpath\n\n          msg.href = this.config.firebaseurl + childpath\n          var url =  msg.href + \".json?shallow=true\"\n\n          if(this.config.fbConnection.passORuid)\n            url += \"&auth=\" + this.config.fbConnection.passORuid\n\n          //apply the queries\n          for (var i=0; i<this.queries.length; i+=1) {\n              var query = this.queries[i];\n              var val\n\n              //try to convert to native type for bools, ints, etc.\n              try{ val = JSON.parse(query.value.toLowerCase() || query.value) }\n              catch(e){ val = query.value}\n\n              switch(query.name){\n                case \"orderByChild\":\n                  url += '&orderBy=\"' + val + '\"'\n                  break;\n                case \"orderByKey\":\n                  url += '&orderBy=\"$key\"'\n                  break;\n                case \"orderByValue\":\n                  url += '&orderBy=\"$value\"'\n                  break;\n                case \"orderByPriority\":\n                  url += '&orderBy=\"$priority\"'\n                  break;\n\n                case \"startAt\":\n                case \"endAt\":\n                case \"equalTo\":\n                case \"limitToFirst\":\n                case \"limitToLast\":\n                  if (typeof val == 'string' || val instanceof String)\n                    url += '&' + query.name + '=\"' + val + '\"'\n                  else\n                    url += '&' + query.name + '='+ val\n                  break;\n\n                default:\n                  //TODO:\n                  break;\n              }\n          }\n\n          var opts = urllib.parse(url);\n          opts.method = \"GET\";;\n          //opts.headers = {};\n\n          //TODO: BUG: There needs to be a request.ontimeout\n          var req = https.request(opts,function(res) {\n              res.setEncoding('utf8');\n              msg.statusCode = res.statusCode;\n              //msg.headers = res.headers;\n              msg.payload = \"\";\n              //msg.url = url;   // revert when warning above finally removed\n              res.on('data',function(chunk) {\n                  msg.payload += chunk;\n              }.bind(this));\n\n              res.on('end',function() {\n                  try { msg.payload = JSON.parse(msg.payload); }\n                  catch(e) { this.warn(\"JSON parse error\"); }\n\n                  if(msg.statusCode != 200){\n                    this.error(msg.payload.error || \"firebase shallow_query error\", msg)\n                    this.status({fill:\"red\",shape:\"ring\",text:msg.payload.error || \"error\"});\n                    setTimeout(this.setStatus, 5000)  //Reset back to the Firebase status after 5 seconds\n                  } else {\n                    if(this.repeatifnull && msg.payload == null && msg.attemptNumber++ < 100 ){ // Repeat sending the request\n                      this.registerListeners(msg)\n                    } else {\n                      this.send(msg);\n                    }\n                    this.setStatus();\n                  }\n              }.bind(this));\n          }.bind(this));\n\n          req.on('error',function(err) {\n              msg.statusCode = err.code;\n              this.error(err.toString() + \" : \" + url, msg);\n              this.status({fill:\"red\",shape:\"ring\",text:err.code});\n              setTimeout(this.setStatus, 5000)  //Reset back to the Firebase status after 5 seconds\n          }.bind(this));\n\n          req.end();\n        }.bind(this);\n\n        this.setStatus = function(){\n          //set = state (depending on the deployment strategy, for newly deployed nodes, some of the events may not be refired...)\n          switch(this.config.fbConnection.lastEvent) {\n            case \"initializing\":\n            case \"connected\":\n            case \"disconnected\":\n            case \"authorized\":\n            case \"unauthorized\":\n            case \"error\":\n            case \"closed\":\n              this[\"fb\" + this.config.fbConnection.lastEvent.capitalize()](this.config.fbConnection.lastEventData)  //Javascript is really friendly about sending arguments to functions...\n              break;\n            // case \"undefined\":\n            // case \"null\":\n            //   break;  //Config node not yet setup\n            default:\n              this.error(\"Bad lastEvent Data from Config Node - \" + this.config.fbConnection.lastEvent)\n          }\n\n        }.bind(this)\n\n        //this.config.fbConnection EventEmitter Handlers\n        this.fbInitializing = function(){  //This isn't being called because its emitted too early...\n          // this.log(\"initializing...\")\n          this.status({fill:\"grey\", shape:\"ring\", text:\"initializing...\"})\n          this.ready = false;\n        }.bind(this)\n\n        this.fbConnected = function(){\n          // this.log(\"connected\")\n          this.status({fill:\"green\", shape:\"ring\", text:\"connected\"})\n          this.ready = false;\n        }.bind(this)\n\n        this.fbDisconnected = function(){\n          // this.log(\"disconnected\")\n          this.status({fill:\"red\", shape:\"ring\", text:\"disconnected\"})\n          this.ready = false;\n        }.bind(this)\n\n        this.fbAuthorized = function(authData){\n          // this.log(\"authorized: \" + JSON.stringify(authData))\n          this.status({fill:\"green\", shape:\"dot\", text:\"ready\"})\n          this.ready = true;\n        }.bind(this)\n\n        this.fbUnauthorized = function(){\n          // this.log(\"unauthorized\")\n          this.status({fill:\"red\", shape:\"dot\", text:\"unauthorized\"})\n          this.ready = false;\n          this.destroyListeners();\n        }.bind(this)\n\n        this.fbError = function(error){\n          //this.log(\"error: \" + JSON.stringify(error))\n          this.status({fill:\"red\", shape:\"ring\", text:error})\n          this.error(error, {})\n          this.destroyListeners();\n        }.bind(this)\n\n        this.fbClosed = function(error){\n          //this.log(\"closed\")\n          this.status({fill: \"gray\", shape: \"dot\", text:\"connection closed\"})\n          this.ready = false;\n          this.destroyListeners();  //TODO: this is being called in too many places but better safe than sorry?  Really need to figure out execution flow of Node-Red and decide if we can only have it here instead of also in this.on(\"close\")\n        }.bind(this)\n\n        //Register Handlers\n        this.config.fbConnection.on(\"initializing\", this.fbInitializing)\n        this.config.fbConnection.on(\"connected\", this.fbConnected)\n        this.config.fbConnection.on(\"disconnected\", this.fbDisconnected)\n        this.config.fbConnection.on(\"authorized\", this.fbAuthorized)\n        this.config.fbConnection.on(\"unauthorized\", this.fbUnauthorized)\n        this.config.fbConnection.on(\"error\", this.fbError)\n        this.config.fbConnection.on(\"closed\", this.fbClosed)\n\n        this.setStatus()\n\n        this.on('input', function(msg) {\n            if(this.ready){\n              this.registerListeners(msg);\n            } else {\n              this.warn(\"Received msg before firebase.once() node was ready.  Not processing: \" + JSON.stringify(msg, null, \"\\t\"))\n            }\n        });\n\n        this.on('close', function() {\n          this.destroyListeners();\n        });\n\n    }\n    RED.nodes.registerType('firebase.once', FirebaseOnce);\n};\n","/home/travis/build/npmtest/node-npmtest-node-red-contrib-firebase/node_modules/node-red-contrib-firebase/firebase/firebase_ondisconnect.js":"module.exports = function(RED) {\n    'use strict';\n    var path= require('path');\n\n    String.prototype.capitalize = function() {\n        return this.charAt(0).toUpperCase() + this.slice(1);\n    }\n\n    function FirebaseOnDisconnect(n) {\n        RED.nodes.createNode(this,n);\n\n        this.config = RED.nodes.getNode(n.firebaseconfig);\n        this.name = n.name;\n        this.childpath = n.childpath;\n        this.method = n.method;\n        this.value = n.value;\n        this.priority = n.priority;\n        this.fbRequests = [];\n\n        this.ready = false;\n\n        this.validMethods = {\n          \"set\": true,\n          \"update\": true,\n          \"remove\": true,\n          \"setWithPriority\": true,\n          \"cancel\": true\n        }\n\n        // Check credentials\n        if (!this.config) {\n            this.status({fill:\"red\", shape:\"ring\", text:\"invalid credentials\"})\n            this.error('You need to setup Firebase credentials!');\n            return\n        }\n\n        this.fbOnComplete = function(error) {\n            //this.log(\"fb oncomplete.  error = \" + error)\n            var msg = this.fbRequests.shift() //Firebase will call these in order for us\n            //TODO: Once Node-Red supports it, we should flash the Node when we receive this data.\n            if(error){\n              //this.log(\"firebase synchronization failed\")\n              this.error(\"firebase synchronization failed - \" + error, msg)\n            }\n        }.bind(this);\n\n\n        //this.config.fbConnection EventEmitter Handlers\n        this.fbInitializing = function(){  //This isn't being called because its emitted too early...\n          // this.log(\"initializing\")\n          this.status({fill:\"grey\", shape:\"ring\", text:\"initializing...\"})\n          this.ready = false;\n        }.bind(this)\n\n        this.fbConnected = function(){\n          // this.log(\"connected\")\n          this.status({fill:\"green\", shape:\"ring\", text:\"connected\"})\n          // this.ready = false;\n        }.bind(this)\n\n        this.fbDisconnected = function(){\n          // this.log(\"disconnected\")\n          this.status({fill:\"red\", shape:\"ring\", text:\"disconnected\"})\n          this.ready = false;\n        }.bind(this)\n\n        this.fbAuthorized = function(authData){\n          // this.log(\"authorized\")\n          this.status({fill:\"green\", shape:\"dot\", text:\"ready\"})\n          this.ready = true;\n          if (this.value != \"msg.payload\" && this.method != \"msg.method\" && this.childpath != \"msg.childpath\"){\n            //this.warn(\"FB Authorized -- explicitly emitting event INPUT\");\n            this.emit('input', {});\n          }\n        }.bind(this)\n\n        this.fbUnauthorized = function(){\n          // this.log(\"unauthorized\")\n          this.status({fill:\"red\", shape:\"dot\", text:\"unauthorized\"})\n          this.ready = false;\n        }.bind(this)\n\n        this.fbError = function(error){\n          // this.log(\"error\")\n          this.status({fill:\"red\", shape:\"ring\", text:error})\n          this.error(error, {})\n        }.bind(this)\n\n        this.fbClosed = function(error){\n          // this.log(\"closed\")\n          this.status({fill: \"gray\", shape: \"dot\", text:\"connection closed\"})\n          this.ready = false;\n        }.bind(this)\n\n        //Register Handlers\n        this.config.fbConnection.on(\"initializing\", this.fbInitializing)\n        this.config.fbConnection.on(\"connected\", this.fbConnected)\n        this.config.fbConnection.on(\"disconnected\", this.fbDisconnected)\n        this.config.fbConnection.on(\"authorized\", this.fbAuthorized)\n        this.config.fbConnection.on(\"unauthorized\", this.fbUnauthorized)\n        this.config.fbConnection.on(\"error\", this.fbError)\n        this.config.fbConnection.on(\"closed\", this.fbClosed)\n\n        //set initial state (depending on the deployment strategy, for newly deployed nodes, some of the events may not be refired...)\n        switch(this.config.fbConnection.lastEvent) {\n          case \"initializing\":\n          case \"connected\":\n          case \"disconnected\":\n          case \"authorized\":\n          case \"unauthorized\":\n          case \"error\":\n          case \"closed\":\n            this[\"fb\" + this.config.fbConnection.lastEvent.capitalize()](this.config.fbConnection.lastEventData)  //Javascript is really friendly about sending arguments to functions...\n            break;\n          // case \"undefined\":\n          // case \"null\":\n          //   break;  //Config node not yet setup\n          default:\n            this.error(\"Bad lastEvent Data from Config Node - \" + this.config.fbConnection.lastEvent)\n        }\n\n        this.on('input', function(msg) {\n          if(this.ready){\n\n            //Parse out msg.method\n            var method = this.method\n            if(method == \"msg.method\"){\n              if(\"method\" in msg){\n                method = msg.method\n              } else {\n                this.error(\"Expected \\\"method\\\" property not in msg object, .onDisconnect() will not be set\", msg)\n                return;\n              }\n            }\n\n            //Parse out msg.payload\n            var value = this.value;\n            if (method != \"setPriority\" && method != \"cancel\"){\n              if (value == \"msg.payload\"){\n                if (\"payload\" in msg){\n                  value = msg.payload;\n                  if (!Buffer.isBuffer(value) && typeof value != \"object\"){\n                    try {\n                      value = JSON.parse(value)\n                    } catch(e){\n                      value = msg.payload.toString();\n                    }\n                  }\n                } else {\n                  this.warn(\"Expected \\\"payload\\\" property not in msg object (setting payload to \\\"null\\\")\", msg);\n                  value = null;\n                }\n              } else if(this.value == \"Firebase.ServerValue.TIMESTAMP\") {\n                value = this.config.fbConnection.Firebase.ServerValue.TIMESTAMP\n              }\n              msg.payload = value;\n            }\n\n            //Parse out msg.priority\n            var priority = null;\n            if (method == \"setPriority\" || method == \"setWithPriority\"){\n              priority = this.priority;\n              if (priority == null){\n                this.error(\"Expected \\\"priority\\\" property not included, .onDisconnect() will not be set\", msg)\n                return;\n              } else if (priority == \"msg.priority\"){\n                if (\"priority\" in msg) priority = msg.priority;\n                else {\n                  this.error(\"Expected \\\"priority\\\" property in msg object, .onDisconnect() will not be set\", msg)\n                  return;\n                }\n              }\n            }\n\n            //Parse out msg.childpath\n            var childpath = this.childpath\n            if(childpath == \"msg.childpath\"){\n              if(\"childpath\" in msg){\n                childpath = msg.childpath\n              }\n            }\n            childpath = childpath || \"/\"\n\n            switch (method) {\n              case \"set\":\n              case \"update\":\n              case \"push\":\n                this.fbRequests.push(msg)\n                this.config.fbConnection.fbRef.child(childpath).onDisconnect()[method](msg.payload, this.fbOnComplete.bind(this)); //TODO: Why doesn't the Firebase API support passing a context to these calls?\n                break;javas\n              case \"remove\":\n                this.fbRequests.push(msg)\n                this.config.fbConnection.fbRef.child(childpath).onDisconnect()[method](this.fbOnComplete.bind(this));\n                break;\n              // case \"setPriority\":\n              //   this.fbRequests.push(msg)\n              //   this.config.fbConnection.fbRef.child(childpath).onDisconnect()[method](priority, this.fbOnComplete.bind(this));\n              //   break;\n              case \"cancel\":\n                this.fbRequests.push(msg)\n                this.config.fbConnection.fbRef.child(childpath).onDisconnect()[method](this.fbOnComplete.bind(this));\n                break;\n              case \"setWithPriority\":\n                this.fbRequests.push(msg)\n                this.config.fbConnection.fbRef.child(childpath).onDisconnect()[method](msg.payload, priority, this.fbOnComplete.bind(this));\n                break;\n              default:\n                this.error(\"Invalid msg.method property \\\"\" + method + \"\\\".  Expected one of the following: [\\\"\" + Object.keys(this.validMethods).join(\"\\\", \\\"\") + \"\\\"].\", msg)\n                break;\n            }\n          } else {\n            this.warn(\"Received msg before firebase modify node was ready.  Not processing: \" + JSON.stringify(msg, null, \"\\t\"))\n          }\n        });\n\n\n          this.on('close', function() {\n            //Cancel modify request to firebase??\n          });\n\n    }\n    RED.nodes.registerType(\"firebase ondisconnect\", FirebaseOnDisconnect);\n\n    RED.httpAdmin.post(\"/firebase/:id/cancelOnDisconnect\", RED.auth.needsPermission(\"firebase.write\"), function(req,res) {\n            var node = RED.nodes.getNode(req.params.id);\n            if (node !== null && typeof node !== \"undefined\" ) {\n              if(node.ready){\n                node.config.fbConnection.fbRef.onDisconnect().cancel(function(error){\n                  if(error){\n                    res.send(502, error)\n                  } else{\n\t\t\t\t\t          node.warn(\"Cancelling all firebase.onDisconnect() values\");\n                    res.send(200)\n                  }\n                }) //Cancel all previously queued onDisconnect() set or update events for this location and all children\n              }\n            } else {\n                res.send(404);\n            }\n        });\n};\n","/home/travis/build/npmtest/node-npmtest-node-red-contrib-firebase/node_modules/node-red-contrib-firebase/firebase/firebase_on.js":"module.exports = function(RED) {\n    'use strict';\n\n    var getPushIdTimestamp = (function getPushIdTimestamp() {\n      var PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\n\n      return function getTimestampFromId(id) {\n        try {\n          var time = 0;\n          var data = id.substr(0, 8);\n\n          for (var i = 0; i < 8; i++) {\n            time = time * 64 + PUSH_CHARS.indexOf(data[i]);\n          }\n\n          return time;\n        } catch(ex){}\n      }\n    })();\n\n    function FirebaseOn(n) {\n        RED.nodes.createNode(this,n);\n\n        this.config = RED.nodes.getNode(n.firebaseconfig);\n        this.childpath = n.childpath;\n        this.atStart = n.atStart;\n        this.eventType = n.eventType;\n\t\t    this.queries = n.queries\n\n        this.ready = false;\n        this.ignoreFirst = this.atStart;\n        this.authorized = false;\n        this.msg = null;\n\n        // Check credentials\n        if (!this.config) {\n            this.status({fill:\"red\", shape:\"ring\", text:\"invalid credentials\"})\n            this.error('You need to setup Firebase credentials!');\n            return\n        }\n\n        this.validEventTypes = {\n          \"value\": true,\n          \"child_added\": true,\n          \"child_changed\": true,\n          \"chiled_removed\": true,\n          \"child_moved\": true,\n          \"shallow_query\": true\n        }\n\n        this.onFBValue = function(snapshot, prevChildName) {\n            //console.log(\"In onFBValue + \" + JSON.stringify(snapshot.val()))\n\n            if(this.ignoreFirst == false){\n              this.ignoreFirst = true\n              return;\n            }\n\n            this.status({fill:\"blue\",shape:\"dot\",text:\"received data\"});\n\n            // if(!snapshot.exists()){\n            //   //The code below will simply send a payload of nul if there is no data\n            // }\n\n            var msg = {};\n            msg.href = snapshot.ref().toString();\n            msg.key = snapshot.key();\n            msg.payload = snapshot.val();\n            if(snapshot.getPriority())\n              msg.priority = snapshot.getPriority();\n            if(prevChildName)\n              msg.previousChildName = prevChildName;\n            if(this.eventType.search(\"child\") != -1 && getPushIdTimestamp(msg.key))  //We probably have a pushID that we can decode\n              msg.pushIDTimestamp = getPushIdTimestamp(msg.key)\n\n\n            this.send(msg);\n            setTimeout(this.setStatus, 500)  //Reset back to the Firebase status after 0.5 seconds\n        }.bind(this);\n\n        this.onFBError = function(error){\n          this.error(error, {})\n          this.status({fill:\"red\",shape:\"ring\",text:error.code || \"error\"});\n          setTimeout(this.setStatus, 5000)  //Reset back to the Firebase status after 5 seconds\n        }.bind(this);\n\n        this.registerListeners = function(msg){\n          //this.log(\"Registering Listener for \" + this.config.firebaseurl + (this.childpath || \"\"))\n\n          if(this.ready == true)\n            return  //Listeners are already created\n\n          this.ready = true;\n          this.ignoreFirst = this.atStart;  //Reset if we are re-registering listeners\n\n          //Create the firebase reference to the path\n          var ref\n          if(this.childpath){\n            ref = this.config.fbConnection.fbRef.child(this.childpath  == \"msg.childpath\" ? this.msg.childpath : this.childpath)  //Decide if we are using our input msg object or the string we were configured with\n          } else {\n            ref = this.config.fbConnection.fbRef\n          }\n\n          //apply the queries\n          for (var i=0; i<this.queries.length; i+=1) {\n              var query = this.queries[i];\n              var val\n\n              switch(query.name){\n                case \"orderByKey\":\n                case \"orderByValue\":\n                case \"orderByPriority\":\n                  ref = ref[query.name]()  //No args //TODO: BUG: Update HTML to hide box for these 3...\n                  break;\n\n                case \"orderByChild\":\n                case \"startAt\":\n                case \"endAt\":\n                case \"equalTo\":\n                case \"limitToFirst\":\n                case \"limitToLast\":\n                  //try to convert to native type for bools, ints, etc.\n                  try{ val = JSON.parse(query.value.toLowerCase() || query.value) }\n                  catch(e){ val = query.value}\n\n                  ref = ref[query.name](val) //TODO: no error checking...\n                  break;\n\n                default:\n                  //TODO:\n                  break;\n              }\n          }\n\n          ref.on(this.eventType == \"msg.eventType\" ? this.msg.eventType : this.eventType, this.onFBValue, this.onFBError, this);\n\n\n        }.bind(this);\n\n        this.destroyListeners = function(){\n          if(this.ready == false)\n            return;\n\n          // We need to unbind our callback, or we'll get duplicate messages when we redeploy\n          if(this.msg == null){ //Not using in input mode - do what we've always done\n            if(this.childpath)\n              this.config.fbConnection.fbRef.child(this.childpath).off(this.eventType, this.onFBValue, this);\n            else\n              this.config.fbConnection.fbRef.off(this.eventType, this.onFBValue, this);\n          } else {  // We've been set by our input port\n            if(this.childpath)\n              this.config.fbConnection.fbRef.child(this.childpath  == \"msg.childpath\" ? this.msg.childpath : this.childpath).off(this.eventType == \"msg.eventType\" ? this.msg.eventType : this.eventType, this.onFBValue, this);\n            else\n              this.config.fbConnection.fbRef.off(this.eventType == \"msg.eventType\" ? this.msg.eventType : this.eventType, this.onFBValue, this);\n          }\n\n          this.ready = false;\n          this.msg == null;\n\n        }.bind(this);\n\n        this.setStatus = function(error){\n          //set = state (depending on the deployment strategy, for newly deployed nodes, some of the events may not be refired...)\n          switch(this.config.fbConnection.lastEvent) {\n            case \"initializing\":\n              this.status({fill:\"grey\", shape:\"ring\", text:\"initializing...\"})\n              break;\n            case \"connected\":\n              this.status({fill:\"green\", shape:\"ring\", text:\"connected\"})\n              break;\n            case \"disconnected\":\n              this.status({fill:\"red\", shape:\"ring\", text:\"disconnected\"})\n              break;\n            case \"authorized\":\n              this.status({fill:\"green\", shape:\"dot\", text:\"ready\"})\n              break;\n            case \"unauthorized\":\n              this.status({fill:\"red\", shape:\"dot\", text:\"unauthorized\"})\n              break;\n            case \"error\":\n              this.status({fill:\"red\", shape:\"ring\", text:error || \"error\"}) //TODO: should we store the last error?\n              break;\n            case \"closed\":\n              this.status({fill: \"gray\", shape: \"dot\", text:\"connection closed\"})\n              break;\n            // case \"undefined\":\n            // case \"null\":\n            //   break;  //Config node not yet setup\n            default:\n              this.error(\"Bad lastEvent Data from Config Node - \" + this.config.fbConnection.lastEvent)\n          }\n\n        }.bind(this)\n\n        //this.config.fbConnection EventEmitter Handlers\n        this.fbInitializing = function(){  //This isn't being called because its emitted too early...\n          // this.log(\"initializing\")\n          this.setStatus();\n        }.bind(this)\n\n        this.fbConnected = function(){\n          // this.log(\"connected\")\n          this.setStatus();\n        }.bind(this)\n\n        this.fbDisconnected = function(){\n          // this.log(\"disconnected\")\n          this.setStatus();\n        }.bind(this)\n\n        this.fbAuthorized = function(authData){\n          // this.log(\"authorized\")\n          this.authorized = true;\n          this.setStatus();\n\n          if((this.eventType != \"msg.eventType\" && this.childpath != \"msg.childpath\") || this.msg != null)\n            this.registerListeners();\n\n        }.bind(this)\n\n        this.fbUnauthorized = function(){\n          // this.log(\"unauthorized\")\n          this.authorized = false;\n          this.setStatus();\n          this.destroyListeners();\n        }.bind(this)\n\n        this.fbError = function(error){\n          // this.log(\"error - \" + error)\n          this.setStatus(error);\n          this.error(error, {})\n        }.bind(this)\n\n        this.fbClosed = function(){\n          // this.log(\"closed\")\n          this.setStatus();\n          this.destroyListeners();  //TODO: this is being called in too many places but better safe than sorry?  Really need to figure out execution flow of Node-Red and decide if we can only have it here instead of also in this.on(\"close\")\n        }.bind(this)\n\n\n        //Register Handlers\n        this.config.fbConnection.on(\"initializing\", this.fbInitializing)\n        this.config.fbConnection.on(\"connected\", this.fbConnected)\n        this.config.fbConnection.on(\"disconnected\", this.fbDisconnected)\n        this.config.fbConnection.on(\"authorized\", this.fbAuthorized)\n        this.config.fbConnection.on(\"unauthorized\", this.fbUnauthorized)\n        this.config.fbConnection.on(\"error\", this.fbError)\n        this.config.fbConnection.on(\"closed\", this.fbClosed)\n\n        // this.log(\"setting initial state to [fb\" + this.config.fbConnection.lastEvent.capitalize()+ \"](\"+this.config.fbConnection.lastEventData+\")\" )\n\n        //set initial state (depending on the deployment strategy, for newly deployed nodes, some of the events may not be refired...)\n        this[\"fb\" + this.config.fbConnection.lastEvent.capitalize()](this.config.fbConnection.lastEventData)  //Javascript is really friendly about sending arguments to functions...\n\n        this.on('input', function(msg) {\n          var eventType\n          if(this.eventType == \"msg.eventType\"){\n            if(\"eventType\" in msg){\n              eventType = msg.eventType\n            } else {\n              this.error(\"Expected \\\"eventType\\\" property in msg object\", msg)\n              return;\n            }\n          } else {\n            eventType = this.eventType\n          }\n\n          if(!(eventType in this.validEventTypes)){\n            this.error(\"Invalid msg.eventType property \\\"\" + eventType + \"\\\".  Expected one of the following: [\\\"\" + Object.keys(this.validEventTypes).join(\"\\\", \\\"\") + \"\\\"].\", msg)\n            return;\n          }\n\n          //Parse out msg.childpath\n          var childpath\n          if(this.childpath == \"msg.childpath\"){\n            if(\"childpath\" in msg){\n              childpath = msg.childpath\n            }\n          }\n          childpath = childpath || \"/\"\n\n          msg.eventType = eventType;\n          msg.childpath = childpath || \"/\";\n\n          this.msg = msg;\n          console.log(msg.childpath)\n\n          //if we are authorized\n          //if we have listerners\n          if(this.authorized == true){\n            if(this.ready == true){ //We have listeners\n              this.destroyListeners();\n              this.registerListeners();\n            } else { // We don't have listeners\n              this.registerListeners();\n            }\n          }\n\n        }.bind(this));\n\n        this.on('close', function() {\n          this.destroyListeners();\n        }.bind(this));\n\n    }\n    RED.nodes.registerType('firebase.on', FirebaseOn);\n};\n"}